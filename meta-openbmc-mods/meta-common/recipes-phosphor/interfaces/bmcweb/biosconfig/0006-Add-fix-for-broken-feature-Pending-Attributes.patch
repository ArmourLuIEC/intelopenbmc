From bedec07809e2d2ecfed9db0d9509d2380ea094b7 Mon Sep 17 00:00:00 2001
From: Arun Lal K M <arun.lal@intel.com>
Date: Wed, 19 Jan 2022 14:44:07 +0000
Subject: [PATCH] Add fix for broken feature 'Pending Attributes'.

Fix is added for the following:
1) GET to 'redfish/v1/Systems/system/Bios'.
2) PATCH to 'redfish/v1/Systems/system/Bios/Settings'.
3) GET to 'redfish/v1/Systems/system/Bios/Settings'.
4) Fix for incremental duplicate values in BiosAttributeRegistry.
5) POST to '/redfish/v1/Systems/system/Bios/Actions
            /Bios.ChangePassword/'.
6) Add support for Enumeration.
7) Support DMTF standard of displaying "Value" in BIOS attribute registries.

Tested:
By giving PATCH to 'redfish/v1/Systems/system/Bios/Settings'
PATCH command raw data:
{
    "data":{
            "AmpPrefetchEnable": "0x1",
            "Ce2LmLoggingEn": "0x1",
            "DfxEadrDebugLogs": "0x2",
            "PsfUrEnable": "0x1",
            "ATS": "0x0"
    }
}

Response:
{
    "@Message.ExtendedInfo": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "Successfully Completed Request",
            "MessageArgs": [],
            "MessageId": "Base.1.8.1.Success",
            "MessageSeverity": "OK",
            "Resolution": "None"
        }
    ]
}

By giving GET to 'redfish/v1/Systems/system/Bios'
Response:
{
    "@Redfish.Settings": {
        "@odata.type": "#Settings.v1_3_0.Settings",
        "SettingsObject": {
            "@odata.id":
      "/redfish/v1/Systems/system/Bios/Settings"
        }
    },
    "@odata.id": "/redfish/v1/Systems/system/Bios",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "Actions": {
        "#Bios.ChangePassword": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword"
        },
        "#Bios.ResetBios": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"
        }
    },
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "AEPErrorInjEn": "0x00",
        "ARIEnable": "0x01",
        "ARIForward": "0x00",
    ...
    ...
    ...
        "txEqCalibration": "0x01",
        "volMemMode": "0x00",
        "wrVrefCenter": "0x01"
    },
    "Description": "BIOS Configuration Service",
    "Id": "BIOS",
    "Links": {
        "ActiveSoftwareImage": {
            "@odata.id":
      "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
        },
        "SoftwareImages": [
            {
                "@odata.id":
        "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
            }
        ],
        "SoftwareImages@odata.count": 1
    },
    "Name": "BIOS Configuration"
}

By giving GET to 'redfish/v1/Systems/system/Bios/Settings'
Response:
{
    "@odata.id": "/redfish/v1/Systems/system/Bios/Settings",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "ATS": "0x0",
        "AmpPrefetchEnable": "0x1",
        "Ce2LmLoggingEn": "0x1",
        "DfxEadrDebugLogs": "0x2",
        "PsfUrEnable": "0x1"
    },
    "Id": "BiosSettingsV1",
    "Name": "Bios Settings Version 1"
}

By giving POST to '/redfish/v1/Systems/system/Bios/Actions
/Bios.ChangePassword/'
Response: Success

By running Redfish-Service-Validator
Result:
Elapsed time: 0:09:36
invalidPropertyValue: 108
metadataNamespaces: 2185
missingNamespaces: 1
optionalAction: 9
pass: 13772
passAction: 22
passGet: 541
reflink: 1
repeat: 47
serviceNamespaces: 75
skipOptional: 9276
unverifiedComplexAdditional: 1
warnDeprecated: 230
warningPresent: 54
Validation has succeeded.

Signed-off-by: Arun Lal K M <arun.lal@intel.com>
Signed-off-by: Snehalatha Venkatesh <snehalathax.v@intel.com>
---
 redfish-core/lib/bios.hpp | 605 +++++++++++++++++++++++++-------------
 1 file changed, 394 insertions(+), 211 deletions(-)

diff --git a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
index bbf9460..c3192dd 100644
--- a/redfish-core/lib/bios.hpp
+++ b/redfish-core/lib/bios.hpp
@@ -12,13 +12,15 @@ map{attributeName,struct{attributeType,readonlyStatus,displayname,
               description,menuPath,current,default,
               array{struct{optionstring,optionvalue}}}}
 */
-using BiosBaseTableType = std::vector<std::pair<
+
+using BiosBaseTableType = boost::container::flat_map<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
         std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
         std::vector<
-            std::tuple<std::string, std::variant<int64_t, std::string>>>>>>;
+            std::tuple<std::string, std::variant<int64_t, std::string>>>>>;
+
 using BiosBaseTableItemType = std::pair<
     std::string,
     std::tuple<
@@ -29,6 +31,13 @@ using BiosBaseTableItemType = std::pair<
 using OptionsItemType =
     std::tuple<std::string, std::variant<int64_t, std::string>>;
 
+using PendingAttributesType = boost::container::flat_map<
+    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
+using PendingAttributesItemType =
+    std::pair<std::string,
+              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
 enum BiosBaseTableIndex
 {
     biosBaseAttrType = 0,
@@ -45,17 +54,7 @@ enum OptionsItemIndex
     optItemType = 0,
     optItemValue
 };
-/*
- The Pending attribute name and new value.
-              ex- { {"QuietBoot",Type.Integer, 0x1},
-                    { "DdrFreqLimit",Type.String,"2933"}
-                  }
-*/
-using PendingAttributesType = std::vector<std::pair<
-    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>>;
-using PendingAttributesItemType =
-    std::pair<std::string,
-              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
 enum PendingAttributesIndex
 {
     pendingAttrType = 0,
@@ -64,30 +63,20 @@ enum PendingAttributesIndex
 static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
-    if (typeDbus == "xyz.openbmc_project.BIOSConfig.Manager."
-                    "AttributeType.Enumeration")
-    {
-        ret = "Enumeration";
-    }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.String")
+    if (typeDbus == "xyz.openbmc_project.BIOSConfig."
+                    "Manager.AttributeType.String")
     {
         ret = "String";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Password")
-    {
-        ret = "Password";
-    }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
                          "Manager.AttributeType.Integer")
     {
         ret = "Integer";
     }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Boolean")
+                         "Manager.AttributeType.Enumeration")
     {
-        ret = "Boolean";
+        ret = "Enumeration";
     }
     else
     {
@@ -96,29 +85,7 @@ static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 
     return ret;
 }
-static std::string mapRedfishToAttrType(const std::string_view type)
-{
-    std::string ret;
-    if (type == "string")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String";
-    }
-    else if (type == "int")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer";
-    }
-    else if (type == "enum")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType."
-              "Enumeration";
-    }
-    else
-    {
-        ret = "UNKNOWN";
-    }
 
-    return ret;
-}
 static std::string mapBoundTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
@@ -201,6 +168,15 @@ inline void
 
                 return;
             }
+
+            if (getObjectType.empty())
+            {
+                BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                messages::internalError(asyncResp->res);
+
+                return;
+            }
+
             const std::string& service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
@@ -220,7 +196,7 @@ inline void
                         asyncResp->res.jsonValue["Attributes"];
                     if (baseBiosTable == nullptr)
                     {
-                        BMCWEB_LOG_ERROR << "baseBiosTable == nullptr ";
+                        BMCWEB_LOG_ERROR << "baseBiosTable is empty";
                         messages::internalError(asyncResp->res);
                         return;
                     }
@@ -230,7 +206,7 @@ inline void
                         const std::string& itemType =
                             std::get<biosBaseAttrType>(item.second);
                         std::string attrType = mapAttrTypeToRedfish(itemType);
-                        if (attrType == "String")
+                        if (attrType == "String" || attrType == "Enumeration")
                         {
                             const std::string* currValue =
                                 std::get_if<std::string>(
@@ -248,7 +224,6 @@ inline void
                         else
                         {
                             BMCWEB_LOG_ERROR << "Unsupported attribute type.";
-                            messages::internalError(asyncResp->res);
                         }
                     }
                 },
@@ -275,8 +250,9 @@ inline void requestRoutesBiosService(App& app)
  */
 inline void requestRoutesBiosChangePassword(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
-        .privileges({{"ConfigureComponents"}})
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword/")
+        .privileges(redfish::privileges::postBios)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
@@ -342,180 +318,303 @@ inline void requestRoutesBiosSettings(App& app)
 {
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
         .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            [](const crow::Request&,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-                asyncResp->res.jsonValue["@odata.id"] =
-                    asyncResp->res.jsonValue["@odata.id"] =
-                        "/redfish/v1/Systems/system/Bios/Settings";
-                asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
-                asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
-                asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
-                asyncResp->res.jsonValue["AttributeRegistry"] =
-                    "BiosAttributeRegistry";
-                asyncResp->res.jsonValue["Attributes"] = {};
+        .methods(
+            boost::beast::http::verb::
+                get)([](const crow::Request&,
+                        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+            asyncResp->res.jsonValue["@odata.id"] =
+                "/redfish/v1/Systems/system/Bios/Settings";
+            asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
+            asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
+            asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
+            asyncResp->res.jsonValue["AttributeRegistry"] =
+                "BiosAttributeRegistry";
+            asyncResp->res.jsonValue["Attributes"] = {};
 
-                crow::connections::systemBus->async_method_call(
-                    [asyncResp](const boost::system::error_code ec,
-                                const GetObjectType& getObjectType) {
-                        if (ec)
-                        {
-                            BMCWEB_LOG_ERROR
-                                << "ObjectMapper::GetObject call failed: "
-                                << ec;
-                            messages::internalError(asyncResp->res);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code ec,
+                            const GetObjectType& getObjectType) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "ObjectMapper::GetObject call failed: " << ec;
+                        messages::internalError(asyncResp->res);
 
-                            return;
-                        }
-                        std::string service = getObjectType.begin()->first;
-
-                        crow::connections::systemBus->async_method_call(
-                            [asyncResp](
-                                const boost::system::error_code ec,
-                                const std::variant<PendingAttributesType>&
-                                    retPendingAttributes) {
-                                if (ec)
-                                {
-                                    BMCWEB_LOG_ERROR
-                                        << "getBiosSettings DBUS error: " << ec;
-                                    messages::resourceNotFound(
-                                        asyncResp->res, "Systems/system/Bios",
-                                        "Settings");
-                                    return;
-                                }
-                                const PendingAttributesType* pendingAttributes =
-                                    std::get_if<PendingAttributesType>(
-                                        &retPendingAttributes);
-                                nlohmann::json& attributesJson =
-                                    asyncResp->res.jsonValue["Attributes"];
-                                if (pendingAttributes == nullptr)
-                                {
-                                    BMCWEB_LOG_ERROR
-                                        << "pendingAttributes == nullptr ";
-                                    messages::internalError(asyncResp->res);
-                                    return;
-                                }
-                                for (const PendingAttributesItemType& item :
-                                     *pendingAttributes)
+                        return;
+                    }
+
+                    if (getObjectType.empty())
+                    {
+                        BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                        messages::internalError(asyncResp->res);
+
+                        return;
+                    }
+
+                    std::string service = getObjectType.begin()->first;
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    const std::variant<PendingAttributesType>&
+                                        retPendingAttributes) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "getBiosSettings DBUS error: " << ec;
+                                messages::resourceNotFound(
+                                    asyncResp->res, "Systems/system/Bios",
+                                    "Settings");
+                                return;
+                            }
+
+                            const PendingAttributesType* pendingAttributes =
+                                std::get_if<PendingAttributesType>(
+                                    &retPendingAttributes);
+                            nlohmann::json& attributesJson =
+                                asyncResp->res.jsonValue["Attributes"];
+                            if (pendingAttributes == nullptr)
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "pendingAttributes is empty";
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+
+                            for (const PendingAttributesItemType&
+                                     pendingAttributesItem : *pendingAttributes)
+                            {
+                                const std::string& biosAttrType =
+                                    std::get<pendingAttrType>(
+                                        pendingAttributesItem.second);
+
+                                std::string itemType =
+                                    mapAttrTypeToRedfish(biosAttrType);
+
+                                if (itemType == "String" ||
+                                    itemType == "Enumeration")
                                 {
-                                    const std::string& key = item.first;
-                                    const std::string& itemType =
-                                        std::get<pendingAttrType>(item.second);
-                                    std::string attrType =
-                                        mapAttrTypeToRedfish(itemType);
-                                    if (attrType == "String")
-                                    {
-                                        const std::string* currValue =
-                                            std::get_if<std::string>(
-                                                &std::get<pendingAttrValue>(
-                                                    item.second));
-                                        attributesJson.emplace(
-                                            key, currValue != nullptr
-                                                     ? *currValue
-                                                     : "");
-                                    }
-                                    else if (attrType == "Integer")
+                                    const std::string* currValue =
+                                        std::get_if<std::string>(
+                                            &std::get<pendingAttrValue>(
+                                                pendingAttributesItem.second));
+
+                                    if (!currValue)
                                     {
-                                        const int64_t* currValue =
-                                            std::get_if<int64_t>(
-                                                &std::get<pendingAttrValue>(
-                                                    item.second));
-                                        attributesJson.emplace(
-                                            key, currValue != nullptr
-                                                     ? *currValue
-                                                     : 0);
+                                        BMCWEB_LOG_ERROR
+                                            << "No string data in pending "
+                                               "attributes item data";
+                                        messages::internalError(asyncResp->res);
+                                        return;
                                     }
-                                    else
+
+                                    attributesJson.emplace(
+                                        pendingAttributesItem.first,
+                                        *currValue);
+                                }
+                                else if (itemType == "Integer")
+                                {
+                                    const int64_t* currValue =
+                                        std::get_if<int64_t>(
+                                            &std::get<pendingAttrValue>(
+                                                pendingAttributesItem.second));
+
+                                    if (!currValue)
                                     {
                                         BMCWEB_LOG_ERROR
-                                            << "Unsupported attribute type.";
+                                            << "No int64_t data in pending "
+                                               "attributes item data";
                                         messages::internalError(asyncResp->res);
+                                        return;
                                     }
+
+                                    attributesJson.emplace(
+                                        pendingAttributesItem.first,
+                                        *currValue);
                                 }
-                            },
-                            service, "/xyz/openbmc_project/bios_config/manager",
-                            "org.freedesktop.DBus.Properties", "Get",
-                            "xyz.openbmc_project.BIOSConfig.Manager",
-                            "PendingAttributes");
-                    },
-                    "xyz.openbmc_project.ObjectMapper",
-                    "/xyz/openbmc_project/object_mapper",
-                    "xyz.openbmc_project.ObjectMapper", "GetObject",
-                    "/xyz/openbmc_project/bios_config/manager",
-                    std::array<const char*, 0>());
-            });
+                                else
+                                {
+                                    BMCWEB_LOG_ERROR
+                                        << "Unsupported attribute type.";
+                                    messages::internalError(asyncResp->res);
+                                    return;
+                                }
+                            }
+                        },
+                        service, "/xyz/openbmc_project/bios_config/manager",
+                        "org.freedesktop.DBus.Properties", "Get",
+                        "xyz.openbmc_project.BIOSConfig.Manager",
+                        "PendingAttributes");
+                },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetObject",
+                "/xyz/openbmc_project/bios_config/manager",
+                std::array<const char*, 0>());
+        });
 
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges({{"ConfigureComponents"}})
-        .methods(boost::beast::http::verb::patch)(
-            [](const crow::Request& req,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-                nlohmann::json inpJson;
+        .privileges(redfish::privileges::patchBios)
+        .methods(
+            boost::beast::http::verb::
+                patch)([](const crow::Request& req,
+                          const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+            nlohmann::json inpJson;
 
-                if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
-                                                  inpJson))
-                {
-                    return;
-                }
+            if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
+                                              inpJson))
+            {
+                BMCWEB_LOG_ERROR << "No 'data' in req!";
+                return;
+            }
 
-                for (auto& attrInfo : inpJson)
-                {
-                    std::optional<std::string> attrName;
-                    std::optional<std::string> attrType;
-                    std::optional<std::string> attrValue;
-                    if (!json_util::getValueFromJsonObject(
-                            attrInfo, "AttributeName", attrName))
-                    {
-                        messages::propertyMissing(asyncResp->res,
-                                                  "AttributeName");
-                        return;
-                    }
-                    if (!json_util::getValueFromJsonObject(
-                            attrInfo, "AttributeType", attrType))
-                    {
-                        messages::propertyMissing(asyncResp->res,
-                                                  "AttributeType");
-                        return;
-                    }
-                    if (!json_util::getValueFromJsonObject(
-                            attrInfo, "AttributeValue", attrValue))
+            if (inpJson.empty())
+            {
+                messages::invalidObject(asyncResp->res,
+                                        crow::utility::urlFromPieces("data"));
+                BMCWEB_LOG_ERROR << "No input in req!";
+                return;
+            }
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, inpJson](const boost::system::error_code ec,
+                                     const GetObjectType& getObjectType) {
+                    if (ec)
                     {
-                        messages::propertyMissing(asyncResp->res,
-                                                  "AttributeValue");
+                        BMCWEB_LOG_ERROR
+                            << "ObjectMapper::GetObject call failed: " << ec;
+                        messages::internalError(asyncResp->res);
+
                         return;
                     }
-                    std::string biosAttrType = mapRedfishToAttrType(*attrType);
 
-                    if (biosAttrType == "UNKNOWN")
+                    if (getObjectType.empty())
                     {
-                        BMCWEB_LOG_ERROR << "Invalid attribute type";
-                        messages::propertyValueNotInList(
-                            asyncResp->res, "AttributeType", *attrType);
+                        BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                        messages::internalError(asyncResp->res);
+
                         return;
                     }
 
-                    PendingAttributesType pendingAttributes;
-                    pendingAttributes.emplace_back(std::make_pair(
-                        *attrName, std::make_tuple(biosAttrType, *attrValue)));
+                    std::string service = getObjectType.begin()->first;
 
                     crow::connections::systemBus->async_method_call(
-                        [asyncResp](const boost::system::error_code ec) {
+                        [asyncResp,
+                         inpJson](const boost::system::error_code ec,
+                                  const std::variant<BiosBaseTableType>&
+                                      retBiosTable) {
                             if (ec)
                             {
                                 BMCWEB_LOG_ERROR
-                                    << "doPatch resp_handler got error " << ec;
+                                    << "getBiosAttributes DBUS error: " << ec;
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+
+                            const BiosBaseTableType* baseBiosTable =
+                                std::get_if<BiosBaseTableType>(&retBiosTable);
+
+                            if (baseBiosTable == nullptr)
+                            {
+                                BMCWEB_LOG_ERROR << "baseBiosTable is empty.";
                                 messages::internalError(asyncResp->res);
                                 return;
                             }
+
+                            PendingAttributesType pendingAttributes{};
+
+                            for (nlohmann::detail::iteration_proxy_value<
+                                     nlohmann::detail::iter_impl<
+                                         const nlohmann::basic_json<>>>&
+                                     attributes : inpJson.items())
+                            {
+                                BiosBaseTableType::const_iterator knobIter =
+                                    baseBiosTable->find(attributes.key());
+                                if (knobIter == baseBiosTable->end())
+                                {
+                                    BMCWEB_LOG_ERROR << "Cannot find "
+                                                     << attributes.key()
+                                                     << " in baseBiosTable";
+                                    messages::propertyValueNotInList(
+                                        asyncResp->res, attributes.key(),
+                                        "data");
+                                    return;
+                                }
+
+                                const std::string& itemType =
+                                    std::get<biosBaseAttrType>(
+                                        knobIter->second);
+                                std::string attrType =
+                                    mapAttrTypeToRedfish(itemType);
+
+                                if (attrType == "String" ||
+                                    attrType == "Enumeration")
+                                {
+                                    std::string val = attributes.value();
+
+                                    pendingAttributes.emplace(
+                                        attributes.key(),
+                                        std::make_tuple(itemType, val));
+                                }
+                                else if (attrType == "Integer")
+                                {
+                                    pendingAttributes.emplace(
+                                        attributes.key(),
+                                        std::make_tuple(
+                                            itemType, static_cast<int64_t>(
+                                                          attributes.value())));
+                                }
+                                else
+                                {
+                                    BMCWEB_LOG_ERROR << "UNKNOWN attrType == "
+                                                     << itemType;
+                                    messages::internalError(asyncResp->res);
+
+                                    return;
+                                }
+                            }
+
+                            if (pendingAttributes.empty())
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "pendingAttributes is empty.";
+                                messages::invalidObject(
+                                    asyncResp->res,
+                                    crow::utility::urlFromPieces("data"));
+                            }
+
+                            crow::connections::systemBus->async_method_call(
+                                [asyncResp](
+                                    const boost::system::error_code ec) {
+                                    if (ec)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "doPatch resp_handler got error "
+                                            << ec << "\n";
+                                        messages::internalError(asyncResp->res);
+                                        return;
+                                    }
+
+                                    messages::success(asyncResp->res);
+                                },
+                                "xyz.openbmc_project.BIOSConfigManager",
+                                "/xyz/openbmc_project/bios_config/manager",
+                                "org.freedesktop.DBus.Properties", "Set",
+                                "xyz.openbmc_project.BIOSConfig.Manager",
+                                "PendingAttributes",
+                                std::variant<PendingAttributesType>(
+                                    pendingAttributes));
                         },
-                        "xyz.openbmc_project.BIOSConfigManager",
-                        "/xyz/openbmc_project/bios_config/manager",
-                        "org.freedesktop.DBus.Properties", "Set",
+                        service, "/xyz/openbmc_project/bios_config/manager",
+                        "org.freedesktop.DBus.Properties", "Get",
                         "xyz.openbmc_project.BIOSConfig.Manager",
-                        "PendingAttributes",
-                        std::variant<PendingAttributesType>(pendingAttributes));
-                }
-            });
+                        "BaseBIOSTable");
+                },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetObject",
+                "/xyz/openbmc_project/bios_config/manager",
+                std::array<const char*, 0>());
+        });
 }
 /**
  * BiosAttributeRegistry class supports handle get method for BIOS attribute
@@ -555,6 +654,15 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
 
                         return;
                     }
+
+                    if (getObjectType.empty())
+                    {
+                        BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                        messages::internalError(asyncResp->res);
+
+                        return;
+                    }
+
                     std::string service = getObjectType.begin()->first;
 
                     crow::connections::systemBus->async_method_call(
@@ -575,8 +683,6 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                             nlohmann::json& attributeArray =
                                 asyncResp->res
                                     .jsonValue["RegistryEntries"]["Attributes"];
-                            nlohmann::json optionsArray =
-                                nlohmann::json::array();
                             if (baseBiosTable == nullptr)
                             {
                                 BMCWEB_LOG_ERROR << "baseBiosTable == nullptr ";
@@ -592,10 +698,11 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                     mapAttrTypeToRedfish(itemType);
                                 if (attrType == "UNKNOWN")
                                 {
-                                    BMCWEB_LOG_ERROR << "attrType == UNKNOWN";
-                                    messages::internalError(asyncResp->res);
-                                    return;
+                                    BMCWEB_LOG_ERROR << "UNKNOWN attrType == "
+                                                     << itemType;
+                                    continue;
                                 }
+
                                 nlohmann::json attributeItem;
                                 attributeItem["AttributeName"] = item.first;
                                 attributeItem["Type"] = attrType;
@@ -609,16 +716,37 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                 attributeItem["MenuPath"] =
                                     std::get<biosBaseMenuPath>(item.second);
 
-                                if (attrType == "String")
+                                if (attrType == "String" ||
+                                    attrType == "Enumeration")
                                 {
                                     const std::string* currValue =
                                         std::get_if<std::string>(
                                             &std::get<biosBaseCurrValue>(
                                                 item.second));
+
+                                    if (!currValue)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "Unable to get currValue, no "
+                                               "std::string data in BIOS "
+                                               "attributes item data";
+                                        continue;
+                                    }
+
                                     const std::string* defValue =
                                         std::get_if<std::string>(
                                             &std::get<biosBaseDefaultValue>(
                                                 item.second));
+
+                                    if (!defValue)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "Unable to get defValue, no "
+                                               "std::string data in BIOS "
+                                               "attributes item data";
+                                        continue;
+                                    }
+
                                     attributeItem["CurrentValue"] =
                                         currValue != nullptr ? *currValue : "";
                                     attributeItem["DefaultValue"] =
@@ -630,10 +758,30 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                         std::get_if<int64_t>(
                                             &std::get<biosBaseCurrValue>(
                                                 item.second));
+
+                                    if (!currValue)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "Unable to get currValue, no "
+                                               "int64_t data in BIOS "
+                                               "attributes item data";
+                                        continue;
+                                    }
+
                                     const int64_t* defValue =
                                         std::get_if<int64_t>(
                                             &std::get<biosBaseDefaultValue>(
                                                 item.second));
+
+                                    if (!defValue)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "Unable to get defValue, no "
+                                               "int64_t data in BIOS "
+                                               "attributes item data";
+                                        continue;
+                                    }
+
                                     attributeItem["CurrentValue"] =
                                         currValue != nullptr ? *currValue : 0;
                                     attributeItem["DefaultValue"] =
@@ -641,12 +789,13 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                 }
                                 else
                                 {
-                                    BMCWEB_LOG_ERROR
-                                        << "Unsupported attribute type.";
-                                    messages::internalError(asyncResp->res);
-                                    return;
+                                    BMCWEB_LOG_ERROR << "UNKNOWN attrType == "
+                                                     << itemType;
+                                    continue;
                                 }
 
+                                nlohmann::json optionsArray =
+                                    nlohmann::json::array();
                                 const std::vector<OptionsItemType>&
                                     optionsVector =
                                         std::get<biosBaseOptions>(item.second);
@@ -661,9 +810,9 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                     if (optItemTypeRedfish == "UNKNOWN")
                                     {
                                         BMCWEB_LOG_ERROR
-                                            << "optItemTypeRedfish == UNKNOWN";
-                                        messages::internalError(asyncResp->res);
-                                        return;
+                                            << "UNKNOWN optItemTypeRedfish == "
+                                            << strOptItemType;
+                                        continue;
                                     }
                                     if (optItemTypeRedfish == "OneOf")
                                     {
@@ -671,7 +820,21 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                             std::get_if<std::string>(
                                                 &std::get<optItemValue>(
                                                     optItem));
-                                        optItemJson[optItemTypeRedfish] =
+
+                                        if (!currValue)
+                                        {
+                                            BMCWEB_LOG_ERROR
+                                                << "Unable to get currValue, "
+                                                   "no "
+                                                   "std::string data in option "
+                                                   "item value";
+                                            continue;
+                                        }
+
+                                        optItemJson["ValueDisplayName"] =
+                                            currValue != nullptr ? *currValue
+                                                                 : "";
+                                        optItemJson["ValueName"] =
                                             currValue != nullptr ? *currValue
                                                                  : "";
                                     }
@@ -681,7 +844,21 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                             std::get_if<int64_t>(
                                                 &std::get<optItemValue>(
                                                     optItem));
-                                        optItemJson[optItemTypeRedfish] =
+
+                                        if (!currValue)
+                                        {
+                                            BMCWEB_LOG_ERROR
+                                                << "Unable to get currValue, "
+                                                   "no "
+                                                   "int64_t data in option "
+                                                   "item value";
+                                            continue;
+                                        }
+
+                                        optItemJson["ValueDisplayName"] =
+                                            currValue != nullptr ? *currValue
+                                                                 : 0;
+                                        optItemJson["ValueName"] =
                                             currValue != nullptr ? *currValue
                                                                  : 0;
                                     }
@@ -689,6 +866,12 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                                     optionsArray.push_back(optItemJson);
                                 }
 
+                                if (optionsArray.empty())
+                                {
+                                    BMCWEB_LOG_ERROR << "optionsArray is empty";
+                                    continue;
+                                }
+
                                 attributeItem["Value"] = optionsArray;
                                 attributeArray.push_back(attributeItem);
                             }
-- 
2.25.1

